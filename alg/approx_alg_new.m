function [ U0 ] = approx_alg_new( A, t, R, opt )
% Approximation algorithms for low-rank approximation to higher-order
% tensors with orthogonal factors.
% This is the avoid-for-loop version by
% frequently using the built-in function arrayfun.
%      A            - The data tensor.
%      t            - Number of orthonormal factors.
%      R            - Number of rank-1 terms.
%      opt.get_v_from_M
%                   - The procedure for computing the vector v from the
%                   matrix M. Currently =
%                   @by_svds|@by_leading_row|@by_random_row|@by_random.
%                   Default = @by_svds.
%     opt.efficient_svd
%                  - = 0|1: Choose whether Ud is efficiently computed. If
%                  n_d < n_1*...*n_{d-1}, it would be better to be 1.
%                  Default 1.
%     U0           -  The feasible solution generated by the algorithm,
%     stored as a cell array of length = ndims(A).

%   Author: Yuning Yang (yyang@gxu.edu.cn)

if nargin < 4, opt.get_v_from_M = @by_svds; opt.efficient_svd = 1; end
if ~isfield(opt,'get_v_from_M')
    get_v_from_M = @by_svds;
else
    get_v_from_M = opt.get_v_from_M;
end
if ~isfield(opt,'efficient_svd')
    efficient_svd = 1;
else
    efficient_svd = opt.efficient_svd;
end

d = ndims(A);
if d<t
    error('t should be smaller than the order of the tensor!')
end
if d<3
    error('You should use a suitable method for the matrix setting!')
end
sz = size(A);
% options controls the accuracy of svds. There is no need to run it to a high accuracy.
% However, it is a bit strange that on my mac mini with Matlab 2015b,
% the svds with the more relaxed options will give an emply xi in most cases,
% whereas such phenomenon will not happen in Matlab 2019b.
if verLessThan('matlab','8.7')
    options.tol = 5*1e-7;
    options.maxit = 100;
else
    options.tol = 5*1e-3;
    options.maxit = 80;
end
options.get_v_from_M = get_v_from_M;

U0 = cell(1,d);
% Compute Ud
if (size(A,d) < numel(A)/size(A,d) ) && efficient_svd
    Ad = tens2mat(A,d,1:d-1); AdAdT = Ad*Ad';
    [Un,l]=eig(AdAdT); [~,idx] = sort(diag(l),'descend');
    U0{d} = Un(:,idx(1:R));
    Y = (U0{d}'*Ad)';
    Au = arrayfun(@(i) vec2tens(Y(:,i),sz(1:d-1),1:(d-1)), 1:R, 'UniformOutput', false);
else
    [Un,l,Y]=svd(tens2mat(A,d,1:d-1),'econ');   % the most expensive line
    U0{d} = Un(:,1:R);
    Au = arrayfun(@(i) vec2tens(Y(:,i)*l(i,i),sz(1:d-1),1:(d-1)), 1:R, 'UniformOutput', false);
end

for j = d-1:-1: d-t+1
    Vj = arrayfun(@(i) tmp_get_v_from_M(Au{i},j,options), 1:R, 'UniformOutput',false); Vj = cell2mat(Vj);
    U0{j} = polar_decomp(Vj);
    Au = arrayfun(@(i) tmprod(Au{i},U0{j}(:,i)',j), 1:R, 'UniformOutput', false);
end

if t < d
    %     Au = arrayfun(@(i) tmprod(Au{i},U0{d-t+1}(:,i)',d-t+1), 1:R, 'UniformOutput', false);
    % Au{i} = A\bigotimes^{d-t+1}_{j=1}\mathbf u_{j,i} \in
    % R^{n_1}\times\cdots\times R^{n_{d-t}}, i=1,...,R.
    xcell = arrayfun(@(i) rank1approx(Au{i}), 1:R, 'UniformOutput', false);
    % xcell is a length-R cell-array; U0{1} = [xcell{1}{1}, xcell{2}{1}, ...,
    % xcell{R}{1}];
    sub = @(X,j) X{j};
    SubCell = @(j) arrayfun(@(i) sub(sub(xcell,i),j),1:R,'un',0);
    Mcell = arrayfun(@(j)  cell2mat(SubCell(j)) ,1:d-t,'un',0);
    U0(1:d-t) = Mcell;
end
end


function Vji = tmp_get_v_from_M(Aui,j,options)
if j >1
    Mi = tens2mat(Aui,j,1:j-1);    % if j=1, Mi is a vector; otherwise we formulate Aui as a matrix of size n_j \times n_1...n_{j-1}
    Vji = options.get_v_from_M(Mi,options);
else
    Vji = Aui;
end
end

